<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Tetris WebGL</title>
<style>
    title{
        color: #110202;
    }
  body { text-align:center; font-family:sans-serif; background:#6b6363c5; color:#fff; }
  #gameUI { margin-top:10px; }
  button {
  margin:5px;
  padding:10px;
  font-size:16px;
  border-radius:5px;
  cursor:pointer;
  transition: 0.2s;
    }
    button:hover { background:#110202; color: white;}
    button:active { background:#888; transform:scale(0.95); }
  #score { font-size:20px; margin-top:10px; }
  #gameover { font-size:24px; font-weight:bold; color:rgb(255, 0, 0); display:none; }
</style>
</head>
<body>
  <h1>Tetris</h1>
  <canvas id="webglcanvas" style="border:2px solid white" width="500" height="500"></canvas>
  <div id="gameUI">
    <button onclick="moverIzquierda()"> ← Izquierda</button>
    <button onclick="bajarRapido()"> ↓ Abajo</button>
    <button onclick="moverDerecha()"> → Derecha</button>
    <button onclick="rotar()"> ←→ Rotar</button>
  </div>
  <div id="score">Puntuación: 0</div>
  <div id="gameover">GAME OVER</div>

  <!-- Imágenes para texturas -->
  <img src="colorAzul.jpg" id="texturaAzul" hidden />
  <img src="colorRojo.jpg" id="texturaRojo" hidden />
  <img src="colorAmarillo.jpg" id="texturaAmarillo" hidden />
  <img src="colorVerde.jpg" id="texturaVerde" hidden />
  <img src="colorNaranja.jpg" id="texturaNaranja" hidden />
  <img src="colorMorado.jpg" id="texturaMorado" hidden />
  <img src="colorCian.jpg" id="texturaCian" hidden />
  <img src="fondo.jpg" id="fondo" hidden />

<script id="vs" type="vertex">
#version 300 es
uniform mat4 uMatrizProyeccion;
uniform mat4 uMatrizModelo;
layout(location = 0) in vec2 aVertices;
layout(location = 1) in vec2 aCoordenadasDeTextura;
out vec2 vCoordenadasDeTextura;
void main() {
    gl_Position = uMatrizProyeccion * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
    vCoordenadasDeTextura = aCoordenadasDeTextura;
}
</script>

<script id="fs" type="fragment">
#version 300 es
precision mediump float;
uniform vec4 uColor;
uniform sampler2D uTextura;
uniform bool uUsarTextura;
in vec2 vCoordenadasDeTextura;
out vec4 color;
void main() {
    if (uUsarTextura) {
        color = texture(uTextura, vCoordenadasDeTextura);
    } else {
        color = uColor;
    }
}
</script>

<script>

function toRadians(grados){ return grados * Math.PI / 180; }
function identidad(r){
  r[0]=1;r[4]=0;r[8]=0;r[12]=0;
  r[1]=0;r[5]=1;r[9]=0;r[13]=0;
  r[2]=0;r[6]=0;r[10]=1;r[14]=0;
  r[3]=0;r[7]=0;r[11]=0;r[15]=1;
}
function traslacion(m,tx,ty,tz){
  let r=[1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1];
  multiplica(m,m,r);
}
function escalacion(m,sx,sy,sz){
  let r=[sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1];
  multiplica(m,m,r);
}
function rotacionZ(m,theta){
  let c=Math.cos(toRadians(theta)),s=Math.sin(toRadians(theta));
  let r=[c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1];
  multiplica(m,m,r);
}
function ortho(r,izq,der,abj,arr,cerca,lejos){
  r[0]=2/(der-izq); r[4]=0; r[8]=0; r[12]=-(der+izq)/(der-izq);
  r[1]=0; r[5]=2/(arr-abj); r[9]=0; r[13]=-(arr+abj)/(arr-abj);
  r[2]=0; r[6]=0; r[10]=-2/(lejos-cerca); r[14]=-(lejos+cerca)/(lejos-cerca);
  r[3]=0; r[7]=0; r[11]=0; r[15]=1;
}
function multiplica(c,a,b){
  let r=new Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let s=0;
      for(let k=0;k<4;k++) s+=a[i+k*4]*b[k+j*4];
      r[i+j*4]=s;
    }
  }
  for(let i=0;i<16;i++) c[i]=r[i];
}

// VARIABLES GLOBALES 
let gl,uColor,uMatrizProyeccion,uMatrizVista,uMatrizModelo,uTextura,uUsarTextura;
let triangulo, fondoRectangulo;
let MatrizProyeccion=new Array(16);
let MatrizVista=new Array(16);
let MatrizModelo=new Array(16);

const columnas=10,filas=20;
let tablero=[]; 
let pieza=null;
let puntaje=0;
let juegoTerminado=false;

// Texturas
let texturas = {};
let texturaFondo;

// Piezas 
const piezas=[
  {forma:[[0,0],[1,0],[0,1],[1,1]],color:[1,1,0,1],textura:"texturaAmarillo"}, // O
  {forma:[[0,0],[-1,0],[1,0],[0,1]],color:[0.6,0,1,1],textura:"texturaMorado"}, // T
  {forma:[[0,0],[0,1],[0,2],[0,3]],color:[0,1,1,1],textura:"texturaCian"}, // I4
  {forma:[[0,0],[0,1],[0,2]],color:[0,1,0,1],textura:"texturaVerde"}, // I3
  {forma:[[0,0],[0,1],[1,0],[2,0]],color:[1,0.5,0,1],textura:"texturaNaranja"}, // L
  {forma:[[0,0],[0,1],[-1,0],[-2,0]],color:[0,0,1,1],textura:"texturaAzul"}, // J
  {forma:[[0,0],[1,0],[0,1],[-1,1]],color:[1,0,0,1],textura:"texturaRojo"}, // S
  {forma:[[0,0],[-1,0],[0,1],[1,1]],color:[0,1,0.5,1],textura:"texturaVerde"}, // Z
];

// FUNCIONES DEL JUEGO
// Crear pieza nueva
function nuevaPieza(){
  let p=piezas[Math.floor(Math.random()*piezas.length)];
  return {bloques:JSON.parse(JSON.stringify(p.forma)),x:5,y:19,color:p.color,textura:p.textura};
}

// Rotar 
function rotar(){
  if(juegoTerminado) return;
  pieza.bloques=pieza.bloques.map(([x,y])=>[-y,x]); 
  if(colisiona()) deshacerRotacion();
}
function deshacerRotacion(){ // inversa
  pieza.bloques=pieza.bloques.map(([x,y])=>[y,-x]);
}

// Colisiones
function colisiona(){
  for(let [dx,dy] of pieza.bloques){
    let x=pieza.x+dx,y=pieza.y+dy;
    if(x<0||x>=columnas||y<0) return true;
    if(y<filas && tablero[y][x]) return true;
  }
  return false;
}

// Guardar pieza en tablero
function fijarPieza(){
  for(let [dx,dy] of pieza.bloques){
    let x=pieza.x+dx,y=pieza.y+dy;
    if(y<filas) tablero[y][x] = {color: pieza.color, textura: pieza.textura};
    else gameOver();
  }
  limpiarFilas();
  pieza=nuevaPieza();
  if(colisiona()) gameOver();
}

// Borrar filas completas
function limpiarFilas(){
  let filasBorradas=0;
  for(let y=0;y<filas;y++){
    if(tablero[y].every(c=>c)) {
      tablero.splice(y,1);
      tablero.push(new Array(columnas).fill(null));
      filasBorradas++;
    }
  }
  puntaje+=filasBorradas*100;
  document.getElementById("score").innerText="Puntuación: "+puntaje;
}

// Movimiento
function moverIzquierda(){ pieza.x--; if(colisiona()) pieza.x++; }
function moverDerecha(){ pieza.x++; if(colisiona()) pieza.x--; }
function bajarRapido(){ pieza.y--; if(colisiona()){ pieza.y++; fijarPieza(); }}

// Game Over
function gameOver(){
  juegoTerminado=true;
  document.getElementById("gameover").style.display="block";
}

function dibuja(){
  gl.clearColor(0.1,0.1,0.1,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Dibujar fondo
  dibujarFondo();

  // Dibujar tablero
  for(let y=0;y<filas;y++){
    for(let x=0;x<columnas;x++){
      if(tablero[y][x]) {
        dibujarBloque(x,y,tablero[y][x].color, tablero[y][x].textura);
      }
    }
  }

  // Dibujar pieza actual
  if(pieza){
    for(let [dx,dy] of pieza.bloques){
      dibujarBloque(pieza.x+dx,pieza.y+dy,pieza.color, pieza.textura);
    }
  }
}

function dibujarFondo(){
  identidad(MatrizModelo);
  escalacion(MatrizModelo, columnas, filas, 1);
  gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
  gl.uniform1i(uUsarTextura, true);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texturaFondo);
  gl.uniform1i(uTextura, 0);
  gl.bindVertexArray(fondoRectangulo);
  gl.drawArrays(gl.TRIANGLES,0,6);
  gl.bindVertexArray(null);
}

function dibujarBloque(x,y,color,texturaId){
  identidad(MatrizModelo);
  traslacion(MatrizModelo,(x-columnas/2+0.5),(y-filas/2+0.5),0);
  escalacion(MatrizModelo,0.9,0.9,1);
  gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
  
  if(texturas[texturaId]) {
    gl.uniform1i(uUsarTextura, true);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texturas[texturaId]);
    gl.uniform1i(uTextura, 0);
  } else {
    gl.uniform1i(uUsarTextura, false);
    gl.uniform4f(uColor,color[0],color[1],color[2],color[3]);
  }
  
  gl.bindVertexArray(triangulo);
  gl.drawArrays(gl.TRIANGLES,0,6);
  gl.bindVertexArray(null);
}

// Cargar texturas
function cargarTextura(gl, imagenId, texturaId) {
  let textura = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, textura);
  
  // Configurar textura
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  
  // Cargar imagen
  let imagen = document.getElementById(imagenId);
  if (imagen.complete) {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
  } else {
    imagen.onload = function() {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imagen);
    };
  }
  
  texturas[texturaId] = textura;
  return textura;
}

// Main del juego
function update(){
  if(!juegoTerminado){
    pieza.y--;
    if(colisiona()){ pieza.y++; fijarPieza(); }
    dibuja();
    setTimeout(update,500);
  }
}

function main(){
  let canvas=document.getElementById("webglcanvas");
  gl=canvas.getContext("webgl2");
  gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

  let vs=gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs,document.getElementById("vs").text.trim());
  gl.compileShader(vs);
  let fs=gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs,document.getElementById("fs").text.trim());
  gl.compileShader(fs);
  let prog=gl.createProgram();
  gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
  gl.useProgram(prog);

  // Crear geometría para los bloques
  let vertices=[-0.5,-0.5, 0.5,-0.5, 0.5,0.5, -0.5,-0.5, 0.5,0.5, -0.5,0.5];
  let coordTextura=[0,0, 1,0, 1,1, 0,0, 1,1, 0,1];
  
  triangulo=gl.createVertexArray();
  gl.bindVertexArray(triangulo);
  
  // Buffer de vértices
  let bufVertices=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,bufVertices);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
  
  // Buffer de coordenadas de textura
  let bufTextura=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,bufTextura);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(coordTextura),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1,2,gl.FLOAT,false,0,0);
  
  gl.bindVertexArray(null);

  // Crear geometría para el fondo
  let verticesFondo=[-0.5,-0.5, 0.5,-0.5, 0.5,0.5, -0.5,-0.5, 0.5,0.5, -0.5,0.5];
  let coordTexturaFondo=[0,0, 1,0, 1,1, 0,0, 1,1, 0,1];
  
  fondoRectangulo=gl.createVertexArray();
  gl.bindVertexArray(fondoRectangulo);
  
  // Buffer de vértices para el fondo
  let bufVerticesFondo=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,bufVerticesFondo);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(verticesFondo),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
  
  // Buffer de coordenadas de textura para el fondo
  let bufTexturaFondo=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,bufTexturaFondo);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(coordTexturaFondo),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1,2,gl.FLOAT,false,0,0);
  
  gl.bindVertexArray(null);

  // Obtener ubicaciones de uniformes
  uColor=gl.getUniformLocation(prog,"uColor");
  uMatrizProyeccion=gl.getUniformLocation(prog,"uMatrizProyeccion");
  uMatrizVista=gl.getUniformLocation(prog,"uMatrizVista");
  uMatrizModelo=gl.getUniformLocation(prog,"uMatrizModelo");
  uTextura=gl.getUniformLocation(prog,"uTextura");
  uUsarTextura=gl.getUniformLocation(prog,"uUsarTextura");

  // Configurar proyección
  ortho(MatrizProyeccion,-columnas/2,columnas/2,-filas/2,filas/2,-1,1);
  gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);
  identidad(MatrizVista);
  gl.uniformMatrix4fv(uMatrizVista,false,MatrizVista);

  // Cargar texturas
  texturaFondo = cargarTextura(gl, "fondo", "fondo");
  cargarTextura(gl, "texturaAzul", "texturaAzul");
  cargarTextura(gl, "texturaRojo", "texturaRojo");
  cargarTextura(gl, "texturaAmarillo", "texturaAmarillo");
  cargarTextura(gl, "texturaVerde", "texturaVerde");
  cargarTextura(gl, "texturaNaranja", "texturaNaranja");
  cargarTextura(gl, "texturaMorado", "texturaMorado");
  cargarTextura(gl, "texturaCian", "texturaCian");

  // Inicializar tablero
  for(let y=0;y<filas;y++) tablero.push(new Array(columnas).fill(null));

  pieza=nuevaPieza();
  update();
}
window.onload=main;
</script>
</body>
</html>