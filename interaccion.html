<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Tetris WebGL</title>
<style>
    title{
        color: #110202;
    }
  body { text-align:center; font-family:sans-serif; background:#6b6363c5; color:#fff; }
  #gameUI { margin-top:10px; }
  button {
  margin:5px;
  padding:10px;
  font-size:16px;
  border-radius:5px;
  cursor:pointer;
  transition: 0.2s;
    }
    button:hover { background:#110202; color: white;}
    button:active { background:#888; transform:scale(0.95); }
  #score { font-size:20px; margin-top:10px; }
  #gameover { font-size:24px; font-weight:bold; color:rgb(255, 0, 0); display:none; }
</style>
</head>
<body>
  <h1>Tetris</h1>
  <canvas id="webglcanvas" style="border:2px solid white" width="500" height="500"></canvas>
  <div id="gameUI">
    <button onclick="moverIzquierda()"> ← Izquierda</button>
    <button onclick="bajarRapido()"> ↓ Abajo</button>
    <button onclick="moverDerecha()"> → Derecha</button>
    <button onclick="rotar()"> ←→ Rotar</button>
    
  </div>
  <div id="score">Puntuación: 0</div>
  <div id="gameover">GAME OVER</div>

<script id="vs" type="vertex">
#version 300 es
uniform mat4 uMatrizProyeccion;
uniform mat4 uMatrizVista;
uniform mat4 uMatrizModelo;
layout(location = 0) in vec2 aVertices;
void main() {
    gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
}
</script>

<script id="fs" type="fragment">
#version 300 es
precision mediump float;
uniform vec4 uColor;
out vec4 color;
void main() {
    color = uColor;
}
</script>

<script>

function toRadians(grados){ return grados * Math.PI / 180; }
function identidad(r){
  r[0]=1;r[4]=0;r[8]=0;r[12]=0;
  r[1]=0;r[5]=1;r[9]=0;r[13]=0;
  r[2]=0;r[6]=0;r[10]=1;r[14]=0;
  r[3]=0;r[7]=0;r[11]=0;r[15]=1;
}
function traslacion(m,tx,ty,tz){
  let r=[1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1];
  multiplica(m,m,r);
}
function escalacion(m,sx,sy,sz){
  let r=[sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1];
  multiplica(m,m,r);
}
function rotacionZ(m,theta){
  let c=Math.cos(toRadians(theta)),s=Math.sin(toRadians(theta));
  let r=[c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1];
  multiplica(m,m,r);
}
function ortho(r,izq,der,abj,arr,cerca,lejos){
  r[0]=2/(der-izq); r[4]=0; r[8]=0; r[12]=-(der+izq)/(der-izq);
  r[1]=0; r[5]=2/(arr-abj); r[9]=0; r[13]=-(arr+abj)/(arr-abj);
  r[2]=0; r[6]=0; r[10]=-2/(lejos-cerca); r[14]=-(lejos+cerca)/(lejos-cerca);
  r[3]=0; r[7]=0; r[11]=0; r[15]=1;
}
function multiplica(c,a,b){
  let r=new Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let s=0;
      for(let k=0;k<4;k++) s+=a[i+k*4]*b[k+j*4];
      r[i+j*4]=s;
    }
  }
  for(let i=0;i<16;i++) c[i]=r[i];
}

// VARIABLES GLOBALES 
let gl,uColor,uMatrizProyeccion,uMatrizVista,uMatrizModelo;
let triangulo;
let MatrizProyeccion=new Array(16);
let MatrizVista=new Array(16);
let MatrizModelo=new Array(16);

const columnas=10,filas=20;
let tablero=[]; // matriz [filas][columnas] para el manejo de 
let pieza=null;
let puntaje=0;
let juegoTerminado=false;

// Piezas 
const piezas=[
  {forma:[[0,0],[1,0],[0,1],[1,1]],color:[1,1,0,1]}, // O
  {forma:[[0,0],[-1,0],[1,0],[0,1]],color:[0.6,0,1,1]}, // T
  {forma:[[0,0],[0,1],[0,2],[0,3]],color:[0,1,1,1]}, // I4
  {forma:[[0,0],[0,1],[0,2]],color:[0,1,0,1]}, // I3
  {forma:[[0,0],[0,1],[1,0],[2,0]],color:[1,0.5,0,1]}, // L
  {forma:[[0,0],[0,1],[-1,0],[-2,0]],color:[0,0,1,1]}, // J
  {forma:[[0,0],[1,0],[0,1],[-1,1]],color:[1,0,0,1]}, // S
  {forma:[[0,0],[-1,0],[0,1],[1,1]],color:[0,1,0.5,1]}, // Z
];

// FUNCIONES DEL JUEGO
// Crear pieza nueva
function nuevaPieza(){
  let p=piezas[Math.floor(Math.random()*piezas.length)];
  return {bloques:JSON.parse(JSON.stringify(p.forma)),x:5,y:19,color:p.color};
}

// Rotar 
function rotar(){
  if(juegoTerminado) return;
  pieza.bloques=pieza.bloques.map(([x,y])=>[-y,x]); 
  if(colisiona()) deshacerRotacion();
}
function deshacerRotacion(){ // inversa
  pieza.bloques=pieza.bloques.map(([x,y])=>[y,-x]);
}

// Colisiones
function colisiona(){
  for(let [dx,dy] of pieza.bloques){
    let x=pieza.x+dx,y=pieza.y+dy;
    if(x<0||x>=columnas||y<0) return true;
    if(y<filas && tablero[y][x]) return true;
  }
  return false;
}

// Guardar pieza en tablero
function fijarPieza(){
  for(let [dx,dy] of pieza.bloques){
    let x=pieza.x+dx,y=pieza.y+dy;
    if(y<filas) tablero[y][x]=pieza.color;
    else gameOver();
  }
  limpiarFilas();
  pieza=nuevaPieza();
  if(colisiona()) gameOver();
}

// Borrar filas completas
function limpiarFilas(){
  let filasBorradas=0;
  for(let y=0;y<filas;y++){
    if(tablero[y].every(c=>c)) {
      tablero.splice(y,1);
      tablero.push(new Array(columnas).fill(null));
      filasBorradas++;
    }
  }
  puntaje+=filasBorradas*100;
  document.getElementById("score").innerText="Puntuación: "+puntaje;
}

// Movimiento
function moverIzquierda(){ pieza.x--; if(colisiona()) pieza.x++; }
function moverDerecha(){ pieza.x++; if(colisiona()) pieza.x--; }
function bajarRapido(){ pieza.y--; if(colisiona()){ pieza.y++; fijarPieza(); }}

// Game Over
function gameOver(){
  juegoTerminado=true;
  document.getElementById("gameover").style.display="block";
}


function dibuja(){
  gl.clearColor(0.1,0.1,0.1,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  for(let y=0;y<filas;y++){
    for(let x=0;x<columnas;x++){
      if(tablero[y][x]) dibujarBloque(x,y,tablero[y][x]);
    }
  }
  // Dibujar pieza actual
  if(pieza){
    for(let [dx,dy] of pieza.bloques){
      dibujarBloque(pieza.x+dx,pieza.y+dy,pieza.color);
    }
  }
}

// Dibujar bloque usando tus matrices
function dibujarBloque(x,y,color){
  identidad(MatrizModelo);
  traslacion(MatrizModelo,(x-columnas/2+0.5),(y-filas/2+0.5),0);
  escalacion(MatrizModelo,0.9,0.9,1);
  gl.uniformMatrix4fv(uMatrizModelo,false,MatrizModelo);
  gl.uniform4f(uColor,color[0],color[1],color[2],color[3]);
  gl.bindVertexArray(triangulo);
  gl.drawArrays(gl.TRIANGLES,0,6);
  gl.bindVertexArray(null);
}

// LOOP DEL JUEGO
function update(){
  if(!juegoTerminado){
    pieza.y--;
    if(colisiona()){ pieza.y++; fijarPieza(); }
    dibuja();
    setTimeout(update,500);
  }
}


function main(){
  let canvas=document.getElementById("webglcanvas");
  gl=canvas.getContext("webgl2");
  gl.viewport(0,0,gl.canvas.width,gl.canvas.height);

  // Shaders
  let vs=gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs,document.getElementById("vs").text.trim());
  gl.compileShader(vs);
  let fs=gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs,document.getElementById("fs").text.trim());
  gl.compileShader(fs);
  let prog=gl.createProgram();
  gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
  gl.useProgram(prog);

  // Cuadrado como 2 triángulos
  let vertices=[-0.5,-0.5, 0.5,-0.5, 0.5,0.5, -0.5,-0.5, 0.5,0.5, -0.5,0.5];
  
  triangulo=gl.createVertexArray();
  gl.bindVertexArray(triangulo);
  let buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
  gl.bindVertexArray(null);

  uColor=gl.getUniformLocation(prog,"uColor");
  uMatrizProyeccion=gl.getUniformLocation(prog,"uMatrizProyeccion");
  uMatrizVista=gl.getUniformLocation(prog,"uMatrizVista");
  uMatrizModelo=gl.getUniformLocation(prog,"uMatrizModelo");

  ortho(MatrizProyeccion,-columnas/2,columnas/2,-filas/2,filas/2,-1,1);
  gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);
  identidad(MatrizVista);
  gl.uniformMatrix4fv(uMatrizVista,false,MatrizVista);

  // Inicializar tablero vacío
  for(let y=0;y<filas;y++) tablero.push(new Array(columnas).fill(null));

  pieza=nuevaPieza();
  update();
}
window.onload=main;
</script>
</body>
</html>
