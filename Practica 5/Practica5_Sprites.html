<!DOCTYPE HTML>
<html>
<head>
  <title>Textura 2D en WebGL 2.0</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <style>
    body { 
      background-color: #111; 
      text-align: center; 
      color: white;
      font-family: sans-serif;
    }
    #webglcanvas {
      display: block;
      margin: 20px auto;
      border: 2px solid #555;
      background-image: url('paisaje.jpeg');
      background-size: cover;
      background-position: center;
    }
    .controles {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-top: 20px;
    }
    button {
      font-size: 32px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: none;
      background-color: #333;
      color: white;
      cursor: pointer;
      transition: 0.2s;
    }
    button:active {
      background-color: #777;
      transform: scale(0.9);
    }
  </style>
</head>
<body>
  <h2>Practica 5 - Sprites</h2>
  <canvas id="webglcanvas" width="626" height="500"></canvas>

  <img src="persona2_adelante.png" id="imgP2_adelante" hidden />
  <img src="persona2_atras.png" id="imgP2_atras" hidden />
  <img src="persona1_adelante.png" id="imgP1_adelante" hidden /> 
  <img src="persona1_atras.png" id="imgP1_atras" hidden /> 
  <img src="persona2_salta_adelante.png" id="imgP2_salta_adelante" hidden />
  <img src="persona2_salta_atras.png" id="imgP2_salta_atras" hidden />
  <img src="arbol2.png" id="imgA1" hidden />
  <img src="arbol1.png" id="imgA2" hidden />

  <div class="controles">
    <button id="btnIzquierda">I</button>
    <button id="btnSalto">S</button>
    <button id="btnDerecha">D</button>
  </div>

  <script id="vs" type="vertex">
    #version 300 es
    precision mediump float;

    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    uniform mat4 uMatrizTextura;

    layout(location = 0) in vec2 aVertices;
    layout(location = 1) in vec2 aCoordenadasDeTextura;

    out vec2 vCoordenadasDeTextura;

    void main() { 
      vCoordenadasDeTextura = (uMatrizTextura * vec4(aCoordenadasDeTextura, 0.0, 1.0)).xy;
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision mediump float;

    uniform sampler2D uUnidadDeTextura;
    in vec2 vCoordenadasDeTextura;
    out vec4 color;

    void main() {
      color = texture(uUnidadDeTextura, vCoordenadasDeTextura);
    }
  </script>

  <script>
"use strict";

// Funciones de matrices
function identidad(m) { for (let i = 0; i < 16; i++) m[i] = (i % 5 === 0) ? 1 : 0; }
function traslacion(m, tx, ty, tz) { m[12] += tx; m[13] += ty; m[14] += tz; }
function escalacion(matriz, sx, sy, sz) { 
  let r = new Array(16);
  r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
  r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
  r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
  r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
  multiplica(matriz, matriz, r);
}
function multiplica(c, a, b) {
  let r = new Array(16);
  for (let i = 0; i < 4; i++){
    for (let j = 0; j < 4; j++){
      let s = 0;
      for (let k = 0; k < 4; k++) s += a[i + k * 4] * b[k + j * 4];
      r[i + j * 4] = s;
    }
  }
  for (let i = 0; i < 16; i++) c[i] = r[i];
}
function ortho(m, izq, der, abj, arr, cerca, lejos) {
  identidad(m);
  m[0] = 2 / (der - izq);
  m[5] = 2 / (arr - abj);
  m[10] = -2 / (lejos - cerca);
  m[12] = -(der + izq) / (der - izq);
  m[13] = -(arr + abj) / (arr - abj);
  m[14] = -(lejos + cerca) / (lejos - cerca);
}

let gl, programaID;
let uMatrizProyeccion, uMatrizVista, uMatrizModelo, uUnidadDeTextura, uMatrizTextura;
let MatrizProyeccion = new Float32Array(16);
let MatrizVista = new Float32Array(16);
let MatrizModelo = new Float32Array(16);
let MatrizTextura = new Float32Array(16);

let rectanguloVAO;
let texturas = {};
let texturaActualP2, texturaActualP1;

let txP2 = 0.0, dtP2 = 0.0;
let txP1 = -5.0, dtP1 = 0.0;
let direccionP2 = 0, direccionP1 = 1;
let velocidad = 8;
let totalFrames = 6;
let contadorFrames = 0;

let saltando = false;
let frameSalto = 0;
let alturaSalto = 0;
let framesSalto = 6; 
let velocidadSubida = 0.15;

let texturaArbol1, texturaArbol2;
let txArbol1 = 5, tyArbol1 = 0.0;   // Árbol derecho
let txArbol2 = -5, tyArbol2 = 0.0;  // Árbol izquierdo
let dtArbol = 0.0; 
let framesArbol = 6; 
let velocidadArbol = 50; // Velocidad del arbol

function cargarTextura(idImagen) {
  let img = document.getElementById(idImagen);
  let tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  return tex;
}

let ultimaDireccionVisualP2 = 1; // 1 = adelante, -1 = atrás

function dibuja() {
  gl.clear(gl.COLOR_BUFFER_BIT);
  contadorFrames++;

  // ÁRBOL 1 izquierda
  identidad(MatrizModelo);
  escalacion(MatrizModelo, 3, 3, 0); 
  traslacion(MatrizModelo, txArbol1, tyArbol1, 0);
  gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

  identidad(MatrizTextura);
  traslacion(MatrizTextura, dtArbol, 0, 0); 
  gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texturaArbol1);
  gl.uniform1i(uUnidadDeTextura, 0);
  gl.bindVertexArray(rectanguloVAO);
  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

  // ÁRBOL 2 derecha
  identidad(MatrizModelo);
  escalacion(MatrizModelo, 3, 3, 0); 
  traslacion(MatrizModelo, txArbol2, tyArbol2, 0);
  gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

  identidad(MatrizTextura);
  traslacion(MatrizTextura, dtArbol, 0, 0); 
  gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texturaArbol2);
  gl.uniform1i(uUnidadDeTextura, 0);
  gl.bindVertexArray(rectanguloVAO);
  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

  if (contadorFrames % velocidadArbol === 0) {
    dtArbol += 1 / framesArbol;
    if (dtArbol >= 1.0) dtArbol = 0.0;
  }

  // PERSONA 2 
  identidad(MatrizModelo);
  traslacion(MatrizModelo, txP2, -4 + alturaSalto, 0);
  gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

  identidad(MatrizTextura);
  traslacion(MatrizTextura, dtP2, 0, 0);
  gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

  if(saltando) {
    if(ultimaDireccionVisualP2 >= 0) {
      texturaActualP2 = texturas["p2_salta_adelante"];
    } else {
      texturaActualP2 = texturas["p2_salta_atras"];
    }

    if(contadorFrames % velocidad === 0) {
      dtP2 += 1 / framesSalto;
      frameSalto++;
      alturaSalto = Math.sin(Math.PI * frameSalto / framesSalto) * 3;
      if(frameSalto >= framesSalto) {
        frameSalto = 0;
        alturaSalto = 0;
        dtP2 = 0;
        saltando = false;
        if(ultimaDireccionVisualP2 >= 0) {
          texturaActualP2 = texturas["p2_adelante"];
        } else {
          texturaActualP2 = texturas["p2_atras"];
        }
      }
    }
  } else if(direccionP2 !== 0) {
    if(direccionP2 > 0) {
      texturaActualP2 = texturas["p2_adelante"];
      ultimaDireccionVisualP2 = 1;
    } else {
      texturaActualP2 = texturas["p2_atras"];
      ultimaDireccionVisualP2 = -1;
    }

    if(contadorFrames % velocidad === 0) {
      dtP2 += 1 / totalFrames;
      if(dtP2 >= 1.0) dtP2 = 0.0;
    }
  }

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texturaActualP2);
  gl.uniform1i(uUnidadDeTextura, 0);
  gl.bindVertexArray(rectanguloVAO);
  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

  txP2 += 0.05 * direccionP2;

  // PERSONA 1
  identidad(MatrizModelo);
  traslacion(MatrizModelo, txP1, -4, 0);
  gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

  identidad(MatrizTextura);
  traslacion(MatrizTextura, dtP1, 0, 0);
  gl.uniformMatrix4fv(uMatrizTextura, false, MatrizTextura);

  gl.bindTexture(gl.TEXTURE_2D, texturaActualP1);
  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

  // Movimiento automático persona1
  txP1 += 0.03 * direccionP1;
  if (contadorFrames % velocidad === 0) {
    dtP1 += 1 / totalFrames;
    if (dtP1 >= 1.0) dtP1 = 0.0;
  }

  if (txP1 > 5) { direccionP1 = -1; texturaActualP1 = texturas["p1_atras"]; }
  if (txP1 < -5) { direccionP1 = 1; texturaActualP1 = texturas["p1_adelante"]; }

  requestAnimationFrame(dibuja);
}

function main() {
  let canvas = document.getElementById("webglcanvas");
  gl = canvas.getContext("webgl2");
  if(!gl){ alert("WebGL 2.0 no soportado"); return; }

  function compilarShader(tipo, fuente) {
    const shader = gl.createShader(tipo);
    gl.shaderSource(shader, fuente);
    gl.compileShader(shader);
    return shader;
  }

  let vs = compilarShader(gl.VERTEX_SHADER, document.getElementById("vs").text.trim());
  let fs = compilarShader(gl.FRAGMENT_SHADER, document.getElementById("fs").text.trim());

  programaID = gl.createProgram();
  gl.attachShader(programaID, vs);
  gl.attachShader(programaID, fs);
  gl.linkProgram(programaID);
  gl.useProgram(programaID);

  uMatrizProyeccion = gl.getUniformLocation(programaID,"uMatrizProyeccion");
  uMatrizVista = gl.getUniformLocation(programaID,"uMatrizVista");
  uMatrizModelo = gl.getUniformLocation(programaID,"uMatrizModelo");
  uUnidadDeTextura = gl.getUniformLocation(programaID,"uUnidadDeTextura");
  uMatrizTextura = gl.getUniformLocation(programaID,"uMatrizTextura");

  const vertices = [-1,-1, 1,-1, 1,1, -1,1];
  const coord_textura = [0,0, 1/6,0, 1/6,1, 0,1];

  rectanguloVAO = gl.createVertexArray();
  gl.bindVertexArray(rectanguloVAO);

  const vb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  const tb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coord_textura), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1,2,gl.FLOAT,false,0,0);

  gl.bindVertexArray(null);

  // Cargar texturas
  texturas["p2_adelante"] = cargarTextura("imgP2_adelante");
  texturas["p2_atras"] = cargarTextura("imgP2_atras");
  texturas["p2_salta_adelante"] = cargarTextura("imgP2_salta_adelante");
  texturas["p2_salta_atras"] = cargarTextura("imgP2_salta_atras");
  texturas["p1_adelante"] = cargarTextura("imgP1_adelante");
  texturas["p1_atras"] = cargarTextura("imgP1_atras");
  texturaArbol1 = cargarTextura("imgA1"); 
  texturaArbol2 = cargarTextura("imgA2"); 

  texturaActualP2 = texturas["p2_adelante"];
  texturaActualP1 = texturas["p1_adelante"];

  ortho(MatrizProyeccion,-8,8,-8,8,-8,8);
  gl.uniformMatrix4fv(uMatrizProyeccion,false,MatrizProyeccion);

  identidad(MatrizVista);
  gl.uniformMatrix4fv(uMatrizVista,false,MatrizVista);

  dibuja();
}

window.onload = () => {
  main();

  const btnDerecha = document.getElementById("btnDerecha");
  const btnIzquierda = document.getElementById("btnIzquierda");
  const btnSalto = document.getElementById("btnSalto");

  btnDerecha.onmousedown = () => { 
    direccionP2 = 1; 
    ultimaDireccionVisualP2 = 1;
    texturaActualP2 = texturas["p2_adelante"]; 
  };
  btnIzquierda.onmousedown = () => { 
    direccionP2 = -1; 
    ultimaDireccionVisualP2 = -1;
    texturaActualP2 = texturas["p2_atras"]; 
  };
  btnDerecha.onmouseup = btnIzquierda.onmouseup =
  btnDerecha.onmouseleave = btnIzquierda.onmouseleave = () => { direccionP2 = 0; };

  btnSalto.onclick = () => {
    if(!saltando) saltando = true;
  };


};
  </script>
</body>
</html>
